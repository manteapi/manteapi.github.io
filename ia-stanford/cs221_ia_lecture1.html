<!DOCTYPE html>
<html lang="en">

<head>

<!-- Encoding -->
<meta http-equiv="Content-Type" content="text/HTML; charset=utf-8"/>

<!-- En-tÃªte de la page -->
<title>Pierre-Luc Manteaux homepage</title>

<!-- <link rel="stylesheet" href="style.css"/> -->
<link rel="stylesheet" href="./../latex2html5.css">
<link rel="stylesheet" href="cs221_course_style.css">

<!-- I love MathJax -->
<!-- <script type="text/javascript"
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>-->
<!-- But MathJax + PSTricks is better -->
<script type="text/x-mathjax-config">
// <![CDATA[
    MathJax.Hub.Config({ 
        TeX: {extensions: ["AMSmath.js", "AMSsymbols.js"]},     
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        showProcessingMessages : false,
        messageStyle : "none" ,    
        showMathMenu: false ,
        tex2jax: {
            processEnvironments: true,
            inlineMath: [ ['$','$'] ],
            displayMath: [ ['$$','$$'], ["\[","\]"] ],
            preview : "none",
            processEscapes: true
        },
        "HTML-CSS": { linebreaks: { automatic:true, width: "latex-container"} }
    });
    // ]]>
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript" src="./../latex2html5.min.js"></script> 

<!--Bootstrap & JQuery library-->
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

<!--Highlight-->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/idea.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</head>

<body onload="start()" class="course">

<div class="container">
    <div class="row">

<main>

<article>
    <header>
        <h1>Artificial Intelligence - Lecture 1 - Introduction</h1>
        <hr>
    </header>
    
    <section class="col-md-12">
        <header>
        <h2>Scattered notes about AI</h2>
        </header>
        
        <h3>Kind of definition</h3>
        <p>
        An AI is an intelligent system able to resolve tasks that combine <strong>high societal impact</strong>, <strong>diversity</strong> and <strong>complexity</strong>. <br/>
            An AI is not necessarily similar to human intelligence. <br/>
            "What is an AI ?", "What is thinking ?" are difficult questions that are tackled in cognitive science. <br/>
            In computer science, the question of "What an AI can do for you ?" is more often addressed. <br/>
        </p>
        
        <h3>Few applications with large societal impact</h3>
            <ul>
                <li>Handwriting recognition - 1983-?</li>
                <li>Machine translation - 1960s-?</li>
                <li>Virtual assistants - Speech recognition and natural language understanding - 2010-?</li>
                <li>Autonomous driving - 1980s-?</li>
            </ul>
        
        <h3>Human vs Machines</h3>
            <ul>
                <li>1997: Deep Blue</li>
                <li>2011: IBM Watson</li>
                <li>2016: AlphaGo</li>
            </ul>
        
        <h3>Challenges</h3>
        <p>
            Complexity = <strong>Resources</strong> + <strong>Information</strong> = Time/Memory + Data
        </p>
        
        <h3>Paradigm</h3>
        <p>
            What to compute + How to compute = <strong>Model</strong> + <strong>Algorithm</strong>
        </p>
    
        <h3>Classification</h3>
        <p>
            AI techniques span from low intelligence to high intelligence model+algorithms.
        </p>
    </section>
    
    <section class="col-md-12">
        <header>
            <h2>Machine Learning</h2>
            <blockquote>
            <p>
                Machine learning allows to shift the complexity from the program to the data.
                Learning algorithm maximizes accuracy on training examples.
                Generalization is a leap of faith at the heart of machine learning algorithm : 
                the trained program will produce good results beyond the set of training examples.
            </p>
            </blockquote>
        </header>
        
        <h3>Low-level intelligence to high level intelligence models</h3>
        <ul>
            <li>
                <strong>Reflex-based models</strong> <br/> 
                Linear classifiers $f(x) = sign\left( \sum_{i} \omega_{i} \phi_{i}(x) \right)$ where $\phi_{i}(x)$ are features and $\omega_{i}$ are weights.
            </li>
            <li>
                <strong>State-based models</strong> <br/>
                A state captures all the relevant information about the past in order to act optimally in the future. <br/>
                Applications : Search problems. <br/>
                Models : markov decision processes, adversarial games, minimum cost paths through graphs.
            </li>
            <li>
                <strong>Variable-based models</strong> <br/> 
                A solution corresponds to an assignment of values to variables. <br/>
                Models : Constraint satisfaction problem, Bayesian networks
            </li>
            <li>
                <strong>Logic</strong> <br/>
                Logic provices a compact language for modeling which gives us more expressivity. <br/>
                Applications : Natural language parsin, knowledge representation, logical inference.
            </li>
        </ul>
        
        <blockquote>
            <p>
                A key challenge is to combine the modeling richness of logic with the robustness and agility of machine learning
            </p>
        </blockquote>
    </section>

    <section class="col-md-12">
        <header>
            <h2>Optimization</h2>
            $$\underset{ x \in \mathcal{C} }{\min} F(x)$$
            <ul>
                <li>$F$ is a function to optimize</li>
                <li>$\mathcal{C}$ is a set of constraints</li>
            </ul>
        </header>
        <h3>Basic tools</h3>
            <ul>
                <li><strong>Discrete optimization</strong> : Dynamic programming</li>
                <li><strong>Continuous optimization</strong> : Gradient descent</li>
            </ul>
    </section>

    <section class="col-md-12">
        <header>
            <h2>Dynamic programming - Levenshtein distance</h2>
            <blockquote>
                <p>
                The Levenshtein distance is an edit distance between two strings $s$ and $t$ which measures the minimum number of character <strong>insertions</strong>, <strong>deletions</strong> and <strong>substitutions</strong> it takes to change $s$ into $t$. This distance can be computed using a <strong>mathematical recurrence</strong>.<br/>
                </p>
            </blockquote>
        </header>
            <h3>Recurrence</h3>
            <p>
                Let $d(m,n)$ be the edit distance between the first $m$ letters of $s$ and the first $n$ letters of $t$. We can compute $d(m,n)$ from $d(m-1,n-1)$ using the following formula
            </p>
                $$
                    d(m,n) = \min\left( 1+d(m-1,n), 1+d(m,n-1), 1_{s_{m},t_{n}}+d(m-1,n-1) \right)
                $$
            <p>
                and the following terminal cases
            </p>
                $$
                    \begin{array}{lll}
                    d(m,n) = m & \text{if} & n=0 \\
                    d(m,n) = n & \text{if} & m=0 \\
                    \end{array}
                $$
            <pre><code class="python">def levenshtein_recursive(s,t) :
    if len(s) == 0 : 
        return len(t)
    elif len(t) == 0 : 
        return len(s)
    else :
        #Cost of a substitution
        cost = 1 if s[len(s)-1] != t[len(t)-1] else 0
        #Case 1 : delete a letter from s
        c1 = 1 + levenshtein_recursive( s[0:len(s)-1], t)
        #Case 2 : delete a letter from t
        c2 = 1 + levenshtein_recursive( s, t[0:len(t)-1])
        #Case 3 : substitute a letter
        c3 = cost  + levenshtein_recursive( s[0:len(s)-1], t[0:len(t)-1])
        return min(c1, c2, c3) 
</code></pre>
            <h3>Implementation - Memoize</h3>
            <p>
                To reduce the complexity of the recursive implementation, we can instead perform an iterative implementation using memoization. Basically, memoization consists in pre-computing and storing values that will be intensively used in order to reduced computational cost. Here the idea is to incrementally compute the distance between all $s$ and $t$ substrings.
            </p>
    </section>
    
</article>
    
</main>

<footer>
    <hr>
    <a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px" src="http://jigsaw.w3.org/css-validator/images/vcss-blue" alt="Valid CSS!" /></a>
    <a href="http://www.mathjax.org"><img title="Powered by MathJax" src="http://cdn.mathjax.org/mathjax/badge/badge.gif" alt="Powered by MathJax" /></a>
    <address>by <a href="mailto:frajus@hotmail.fr">Frajus</a></address>
</footer>

    </div> <!--class=container-->
</div> <!--class=row-->

</body>

</html>
